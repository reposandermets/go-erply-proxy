package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"sort"
	"strings"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/gorilla/mux"
)

type BrandCreateRequestDescription struct {
	En string `json:"en,omitempty"`
}

type BrandCreateRequest struct {
	Description *BrandCreateRequestDescription `json:"description,omitempty"`
	Name        string                         `json:"name,omitempty"`
}

type BrandResponse struct {
	Added       int32                          `json:"added,omitempty"`
	Addedby     string                         `json:"addedby,omitempty"`
	Changed     int32                          `json:"changed,omitempty"`
	Changedby   string                         `json:"changedby,omitempty"`
	Description *BrandCreateRequestDescription `json:"description,omitempty"`
	Id          int32                          `json:"id,omitempty"`
	Name        string                         `json:"name,omitempty"`
}

type ErrorResponse struct {
	Message string `json:"message,omitempty"`
}

type Route struct {
	Name        string
	Method      string
	Pattern     string
	HandlerFunc http.HandlerFunc
}

func Index(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello World!")
}

// GenerateUniqueKey generates a unique key from the request URL.
func GenerateUniqueKey(r *http.Request) (string, string) {
	// Get the URI path
	uriPath := r.URL.Path

	// Get the sorted URL parameters
	params := r.URL.Query()
	paramKeys := make([]string, 0, len(params))
	for key := range params {
		paramKeys = append(paramKeys, key)
	}
	sort.Strings(paramKeys)

	var paramList []string
	for _, key := range paramKeys {
		values := params[key]
		for _, value := range values {
			paramList = append(paramList, fmt.Sprintf("%s=%s", key, value))
		}
	}

	key1 := uriPath
	key2 := strings.Join(paramList, "_")
	return key1, key2
}

// GetFromCache retrieves data from Redis cache using the unique key.
func GetFromCache(ctx context.Context, key string) (string, error) {
	// Retrieve the Redis client from the context
	client := ctx.Value("redis").(*redis.Client)

	// Check if the key exists in the cache
	data, err := client.Get(ctx, key).Result()
	if err != nil {
		if err == redis.Nil {
			// Key does not exist in the cache
			return "", nil
		}
		// Error occurred while accessing Redis
		return "", err
	}

	// Key exists in the cache, return the data
	return data, nil
}

// SaveToCache saves data to Redis cache using the composite keys.
func SaveToCache(ctx context.Context, key1, key2, data string) error {
	// Retrieve the Redis client from the context
	client := ctx.Value("redis").(*redis.Client)

	// Create a composite key
	compositeKey := key1 + "|" + key2

	// Save data to Redis cache with the composite key
	err := client.Set(ctx, compositeKey, data, 0).Err()
	if err != nil {
		// Error occurred while saving to Redis
		return err
	}

	// Data successfully saved to cache
	return nil
}

// GetRedisClientFromContext retrieves the Redis client from the request context.
func GetRedisClientFromContext(ctx context.Context) (*redis.Client, error) {
	client, ok := ctx.Value("redis").(*redis.Client)
	if !ok {
		return nil, errors.New("Redis client not found in context")
	}
	return client, nil
}

// ClearCache clears the cache by the key.
func ClearCache(ctx context.Context, client *redis.Client, key string) error {
	// Find keys matching the provided key pattern
	keys, err := client.Keys(ctx, key+"|*").Result()
	if err != nil {
		// Error occurred while accessing Redis
		return err
	}

	// Delete the keys matching the pattern
	if len(keys) > 0 {
		err = client.Del(ctx, keys...).Err()
		if err != nil {
			// Error occurred while deleting keys from Redis
			return err
		}
	}

	// Cache cleared successfully
	return nil
}

// FlushRedis flushes (empties) the entire Redis database.
func FlushRedis(ctx context.Context, client *redis.Client) error {
	statusCmd := client.FlushAll(ctx)
	return statusCmd.Err()
}

func V1BrandGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	split := strings.Split(r.Header.Get("Authorization"), ":")
	if len(split) != 2 {
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(`{"message":"Unauthorized"}`))
		return
	}

	key1, key2 := GenerateUniqueKey(r)
	data, _ := GetFromCache(r.Context(), key1+"|"+key2)

	if data == "" {
		log.Println("Cache miss")
		// Cache miss, get data from the database
		// clientCode := split[0]
		// sessionKey := split[1]
		// data = GetBrandFromErplyAPI(r)

		data = `{"id":1,"name":"Brand 1","description":{"en":"Brand 1 description"}}`
		// Save data to cache
		err := SaveToCache(r.Context(), key1, key2, data)
		if err != nil {
			// Error occurred while saving to Redis
			log.Printf("Error saving to cache: %v\n", err)
		}
	} else {
		// Cache hit, return data
		log.Println("Cache hit")
	}
	fmt.Printf("reqLookupKey: %s\n", data)
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(data))
}

func V1BrandPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	//a, _ := GetRedisClientFromContext(r.Context())

	// go ClearCache(r.Context(), , "/v1/brand")

}

type Routes []Route

var routes = Routes{
	Route{
		"Index",
		"GET",
		"/",
		Index,
	},
	Route{
		"V1BrandGet",
		strings.ToUpper("Get"),
		"/v1/brand",
		V1BrandGet,
	},
	Route{
		"V1BrandPost",
		strings.ToUpper("Post"),
		"/v1/brand",
		V1BrandPost,
	},
}

func NewRouter(client *redis.Client) *mux.Router {
	router := mux.NewRouter().StrictSlash(true)
	for _, route := range routes {
		var handler http.Handler
		handler = route.HandlerFunc
		handler = Logger(handler, route.Name)

		// Wrap the handler with the context-aware middleware
		handler = WithRedisContext(handler, client)

		router.
			Methods(route.Method).
			Path(route.Pattern).
			Name(route.Name).
			Handler(handler)
	}
	return router
}

func WithRedisContext(handler http.Handler, client *redis.Client) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Create a new context with the Redis client
		ctx := context.WithValue(r.Context(), "redis", client)

		// Serve the request with the new context
		handler.ServeHTTP(w, r.WithContext(ctx))
	})
}

func Logger(inner http.Handler, name string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		inner.ServeHTTP(w, r)
		log.Printf(
			"%s %s %s %s",
			r.Method,
			r.RequestURI,
			name,
			time.Since(start),
		)
	})
}

// Periodically clear the cache every 10 seconds
func periodicallyClearCache(client *redis.Client) {
	ticker := time.NewTicker(10 * time.Second)
	for range ticker.C {
		// Clear cache by the key ("/v1/brand")
		err := FlushRedis(context.Background(), client)
		if err != nil {
			fmt.Println("Error occurred while flushing cache:", err)
		} else {
			fmt.Println("Cache flushed successfully")
		}
	}
}

func main() {
	// Initialize Redis client
	redisClient := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379", // Update with your Redis server address
		Password: "",               // Update with your Redis server password
		DB:       0,                // Update with the desired Redis database number
	})

	// Close the Redis client when main() exits
	defer redisClient.Close()

	go periodicallyClearCache(redisClient)
	router := NewRouter(redisClient)
	log.Fatal(http.ListenAndServe(":8081", router))
}
